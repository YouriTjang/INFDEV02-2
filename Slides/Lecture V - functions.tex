\documentclass{beamer}
\usetheme[hideothersubsections]{HRTheme}
\usepackage{beamerthemeHRTheme}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[space]{grffile}

\title{Functions}

\author{TEAM INFDEV}

\institute{Hogeschool Rotterdam \\ 
Rotterdam, Netherlands}

\date{}

\begin{document}
\maketitle

\SlideSection{Introduction}
\SlideSubSection{Syntax and semantics}
\begin{slide}{
\item We will now describe how Python functions work precisely
\item This is a \textbf{fundamental} bit of knowledge that determines if you really do learn how to program or not
\item This \textbf{absolutely requires} a lot of focus to get
\item Please panic a bit on the inside
}\end{slide}

\SlideSubSection{Subtleties that make functions ``fun'' to use}
\begin{slide}{
\item About variables
\begin{itemize}
\item Variables and parameters inside a function have precise \textbf{scope} (visibility)
\item Primitive values given as parameters can be \textbf{changed only locally} to the function
\item References given as parameters can be \textbf{permanently changed} from within the function
\item Global variables defined outside the function may be \textbf{read but not changed} from within the function\footnote{\textbf{Unless you use some tricks we strongly discourage}}
\end{itemize}
\item About behaviour
\begin{itemize}
\item A function may \textbf{call itself}, in a process known as \textbf{recursion}
\item A function may \textbf{get as parameters and return other functions}, in a process known as \textbf{higher order functions}
\end{itemize}
}\end{slide}

\SlideSubSection{Local and global variables (basics of scope)}
\begin{slide}{
\item The parameters of a function are added to the list of accessible variables
\item They are only visible from inside the function
\item Global variables are also visible from inside the function
}\end{slide}

\begin{slide}{
\item Every call to a function generates a new value of the stack memory \texttt{S}
\item This contains (private copy of) all local variables
\item The heap memory \texttt{H} remains the same
\item The original stack memory (the \textbf{global variables}) remains accessible, just read-only 
}\end{slide}

\begin{slide}{
\item Every call to a function also reserves some special locations in the stack
\item The local \texttt{PC} of the function
\item The local variables of the function
\item The returned value when the function is done
}\end{slide}

\begin{frame}[fragile]{Locals and globals}
\begin{codewithblock}{\item \texttt{x} is a global variable, visible outside and inside the function \item \texttt{z} is a local variable, visible only inside the function \pause \item \textbf{What does this program print?} \pause \item \texttt{10}, \texttt{30}, \texttt{20}}
x = 1

def f(z):
  return x * z

print(f(10))
print(f(30))
x = 2
print(f(10))
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{memorytable}
{|c|}{PC}{1}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|}{PC & x}{\red{6} & \red{1}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{memorytable}
{|c|c|}{PC & x}{\red{6} & \red{1}}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & z}{6 & 1 & \red{nil} & \red{4} & \red{10}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & z}{6 & 1 & nil & 4 & 10}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|}{PC & x & f}{\red{7} & 1 & 10}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{memorytable}
{|c|c|c|}{PC & x & f}{7 & 1 & 10}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|}{PC & x}{\red{8} & \red{2}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & z}{8 & 2 & \red{nil} & \red{4} & 10}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|}{PC & x & f}{\red{8} & 2 & \red{20}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{codewithblock}{\item \texttt{x} is a global variable, visible outside and inside the function \item \texttt{z} is a local variable, visible only inside the function \pause \item \textbf{What does this program do?} \pause \item Crash with \texttt{NameError: name 'z' is not defined}}
x = 1

def f(z):
  return x * z

print(f(10))
x = 2
print(f(10))
print(z)
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{Locals and globals}
\begin{codewithblock}{\item \texttt{z} is a local variable, visible only inside the function \pause \item \textbf{What does this program print?} \pause \item \texttt{22}, \texttt{62}}
def f(z):
  z = z + 1
  return z * 2

print(f(10))
print(f(30))
\end{codewithblock}
\end{frame}

\SlideSubSection{Shadowing}
\begin{slide}{
\item The parameters of a function have priority over globals
\item They supersede global variables of the same name
}\end{slide}

\begin{frame}[fragile]{Shadowing}
\begin{codewithblock}{\item \texttt{x} is a global variable, potentially visible inside the function \item \texttt{x} is also a local variable of the function, which has priority over the global \texttt{x} \pause \item \textbf{What does this program print?} \pause \item \texttt{20}, \texttt{40}}
x = 1

def f(x):
  return x * 2

print(f(10))
print(f(20))
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{Shadowing}
\begin{memorytable}
{|c|c|}{PC & x}{6 & 1}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(x):
  return x * 2

print(f(10))
print(f(20))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & x}{6 & 1 & \red{nil} & \red{4} & \red{10}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Shadowing}
\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & x}{6 & 1 & nil & 4 & 10}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(x):
  return x * 2

print(f(10))
print(f(20))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|}{PC & x & f}{7 & 1 & \red{20}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Shadowing}
\begin{memorytable}
{|c|c|c|}{PC & x & f}{7 & 1 & 20}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(x):
  return x * 2

print(f(10))
print(f(20))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & x}{7 & 1 & \red{nil} & \red{4} & \red{20}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Shadowing}
\begin{memorytable}
{|c|c|c|c|c|}{PC & x & f & PC & x}{7 & 1 & nil & 4 & 20}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
x = 1

def f(x):
  return x * 2

print(f(10))
print(f(20))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|}{PC & x & f}{\red{8} & 1 & \red{40}}
{|c|}{}{}
\end{memorytable} \ \\
\end{frame}

\SlideSubSection{Recursion}
\begin{slide}{
\item (Recursive) functions are all functions that call themselves in their bodies
\item This is based on the principle of induction and in general a very powerful technique
\item This leads to a compacter and often more easily correct representation
\begin{itemize}
\item Code is not easier to read, especially to the untrained eye
\end{itemize}
}\end{slide}

\begin{slide}{
\item Remember that calling a function creates a new instance of stack memory
\item Recursive functions do this a lot
\item Each recursive call has its own environment
}\end{slide}

\begin{frame}[fragile]{Recursion}
\begin{codewithblock}{\item How many \texttt{l}'s shall we have? \pause \item As many as the nodes of the initial value}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
\end{codewithblock}
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|}{PC}{7}
{|c|}{}{}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|}{PC & length & PC & l}{7 & \red{nil} & 2 & \red{ref(2)}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|}{PC & length & PC & l}{7 & nil & 2 & ref(2)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|}{PC & length & PC & l}{7 & nil & \red{5} & ref(2)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|}{PC & length & PC & l}{7 & nil & 5 & ref(2)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & \red{nil} & \red{2} & \red{ref(1)}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & nil & 2 & ref(1)}
{|c|c|c|}{0 & 1 & 2}{[E $ \mapsto $ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & nil & \red{5} & ref(1)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & nil & 5 & ref(1) & \red{nil} & \red{2} & \red{ref(0)}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & nil & 5 & ref(1) & nil & \red{3} & ref(0)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l & length & PC & l}{7 & nil & 5 & ref(2) & nil & 5 & ref(1) & nil & 3 & ref(0)}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l & length}{7 & nil & 5 & ref(2) & nil & 5 & ref(1) & \red{0}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|c|c|c|}{PC & length & PC & l & length & PC & l & length}{7 & nil & 5 & ref(2) & nil & 5 & ref(1) & 0}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|c|c|c|}{PC & length & PC & l & length}{7 & nil & 5 & ref(2) & \red{0+1}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|}{PC & length & PC & l & length}{7 & nil & 5 & ref(2) & 1}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|c|}{PC & length}{7 & \red{2}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\begin{frame}[fragile]{Recursion}
\begin{memorytable}
{|c|c|c|c|c|}{PC & length}{7 & 2}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\

\begin{lstlisting}
def length(l):
  if l.IsEmpty:
    return 0
  else:
    return length(l.Tail) + 1
    
print(length(Node(1,Node(2,Empty))))
\end{lstlisting}

\pause

\begin{memorytable}
{|c|}{PC}{\red{8}}
{|c|c|c|}{0 & 1 & 2}{[E $\mapsto$ true] & [E $\mapsto$ false; V $\mapsto$ 2; T $\mapsto$ ref(0)] & [E $\mapsto$ false; V $\mapsto$ 1; T $\mapsto$ ref(1)]}
\end{memorytable} \ \\
\end{frame}

\SlideSection{Assignments}
\SlideSubSection{Build and test, on paper...}
\begin{slide}{
\item A function \texttt{add} that increments all elements of a list by a fixed value:
\begin{itemize}
\item \texttt{add(10, Node(1,Node(2,Node(3,Empty)))) -> Node(11,Node(12,Node(13,Empty)))}
\end{itemize}
\item A function \texttt{filterEven} that removes all odd elements from a list:
\begin{itemize}
\item \texttt{filterEven(Node(1,Node(2,Node(3,Empty)))) -> Node(2,Empty)}
\end{itemize}
\item A function \texttt{sum} that adds all elements of a list:
\begin{itemize}
\item \texttt{sum(Node(1,Node(2,Node(3,Empty)))) -> 6}
\end{itemize}
}\end{slide}

\SlideSection{Conclusion}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item Often, user code needs to perform operations that are similar to each other
\item Through the mechanism of function definition, we can recycle code
\item Functions can encode algorithms in many way
\begin{itemize}
\item Simple code abstractions to avoid repetition
\item Recursive problems
\end{itemize}
}\end{slide}

\begin{thankyou}
\end{thankyou}

\end{document}

\begin{slide}{
\item ...
}\end{slide}

\begin{frame}[fragile]
\begin{lstlisting}
...
\end{lstlisting}
\end{frame}
