\documentclass{beamer}
\usetheme[hideothersubsections]{HRTheme}
\usepackage{beamerthemeHRTheme}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{MnSymbol}

\title{Data structures}

\author{TEAM INFDEV}

\institute{Hogeschool Rotterdam \\ 
Rotterdam, Netherlands}

\date{}

\begin{document}
\maketitle

\SlideSection{Introduction}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item Walkthrough retake exam
\item Mechanism of abstraction
\item The need for data structures
\item Classes as data structures in Python
}\end{slide}

\SlideSection{What is abstraction?}
\SlideSubSection{Introduction}
\begin{slide}{
\item The big issue of the whole course is \textbf{abstraction} in programming
\item Abstraction is a fundamental concept in programming to reduce repetition
\item We sit atop a mountain of abstraction, which we make taller at every iteration
}\end{slide}

\SlideSubSection{Grab the student next to you}
\begin{slide}{
\item Describe what you just did so that someone else can perform the same action
\pause
\item Now add specific details about the movements of your arm and phalanges (pieces of fingers)
\pause
\item Now realize that there are even more subcomponents: individual muscles, tendons, etc.
\pause
\item But then we have also cells that make these up
\item ...
}\end{slide}

\SlideSubSection{Human love for abstraction}
\begin{slide}{
\item Our brain cannot handle so many details
\item To cope with this, we are structured in layers
\item Our consciousness manipulates only the upper layers with simple instructions
\item \textit{Raise arm above head}
}\end{slide}

\begin{slide}{
\item The same happens with regular language
\item ``\textit{Go buy a liter of milk}'' is quite a short description
\item The underlying operation is very complex
}\end{slide}

\begin{frame}[fragile]{Complexity of simple instructions}
\begin{lstlisting}
Go buy a liter of milk =
  Turn game off
  Get up from the couch
  Curse the instruction giver
  Get dressed
  Put money in pocket
  Leave house
  Reach nearest shop
  Enter shop
  Find milk
  Take one liter bottle
  Pay milk
  Go home
  Give milk to instruction giver
\end{lstlisting}
\end{frame}

\begin{slide}{
\item And clearly something like ``\textit{reach nearest shop}'' is not a trivial instruction by itself
\item Think about all the things you give for granted
\begin{itemize}
\item Crossing roads
\item Traffic lights
\item Pathfinding
\item Road work and obstructions
\item Use of transportation methods
\item ...
\end{itemize}
}\end{slide}

\SlideSection{Data structures}
\SlideSubSection{Flying back to Earth}
\begin{slide}{
\item How is this relevant for programmers?
\item We have a similar issue with a modern computer
}\end{slide}

\begin{frame}[fragile]{A single Python instruction runs}
\begin{lstlisting}
+-----------------+
| VM instructions |
+----------------------+
| Machine instruction  |
+---------------------------+
| CPU components            |
+--------------------------------+
| Logic gates                    |
+--------------------------------+
...
\end{lstlisting}
\end{frame}

\begin{slide}{
\item Moreover, sometimes we have repetition of constructs in our own code
\item This means that we would like to extend the pyramid with our own stuff
}\end{slide}

\begin{frame}[fragile]{A single Python program runs}
\begin{lstlisting}
+------------+
| Own stuff  |
+-----------------+
| VM instructions |
+----------------------+
| Machine instruction  |
+---------------------------+
| CPU components            |
+--------------------------------+
| Logic gates                    |
+--------------------------------+
...
\end{lstlisting}
\end{frame}

\SlideSubSection{What kind of ``\textit{own stuff}''?}
\begin{slide}{
\item Any recurring structure, code, etc.
\item We do not want to repeat it every time
\item We just give it a name, instead of specifying it every time
\item The actual goal is to make things simpler
\begin{itemize}
\item Code reuse, maintainability, etc. do not exist
\item It is all just \textbf{properly built abstractions that make reasoning about code easier}
\end{itemize}
}\end{slide}

\begin{frame}[fragile]{Repeated code}
\begin{lstlisting}
playerOneName = "P1"
playerOnePositionX = 0.0
playerOnePositionY = 0.0

playerTwoName = "P2"
playerTwoPositionX = 5.0
playerTwoPositionY = 0.0

playerThreeName = "P3"
playerThreePositionX = 10.0
playerThreePositionY = 0.0
\end{lstlisting}

\pause
Now let's add a score, an exp level, etc.

\pause
Does it scale well?
\end{frame}

\SlideSubSection{Make some examples}
\begin{slide}{
\item \textbf{Everyone make an example of repeated structures of data.}
\item \textbf{Some of you will present theirs}
}\end{slide}

\SlideSection{General idea}
\SlideSubSection{Introduction}
\begin{slide}{
\item A possible solution to this problem is capturing the repetition of data structures
\item With a name, and a specification of what is common about them
}\end{slide}

\SlideSubSection{Fundamental ingredients of the solution}
\begin{slide}{
\item Brains of the programmer, always active
\item Abstraction requires awareness and experience
\item It is as much technique as it is art
}\end{slide}
% Not only about how you define datastructures, but at least as much a design art (creative and thinking come into play)


\begin{frame}[fragile]{Repeated code}
\begin{lstlisting}
playerOneName = "P1"
playerOnePositionX = 0.0
playerOnePositionY = 0.0

playerTwoName = "P2"
playerTwoPositionX = 5.0
playerTwoPositionY = 0.0

playerThreeName = "P3"
playerThreePositionX = 10.0
playerThreePositionY = 0.0
\end{lstlisting}
\end{frame}

\begin{slide}{
\item We observe that there is an underlying pattern, which we will call \textbf{abstraction}
\item The pattern, or abstraction, comes repeated in several \textbf{concrete instances} in our program
\pause
\item In the program above this is fairly obvious, in real life not always really :)
}\end{slide}

\begin{slide}{
\item A proper name for the abstraction
\item \textbf{For example?} \pause \texttt{Player}
}\end{slide}

\begin{slide}{
\item A set of common attributes
\item All characterizing aspects of the abstraction that are common to all its instances
\item \textbf{For example?} \pause \texttt{Name}, \texttt{PositionX}, \texttt{PositionY}
}\end{slide}

\begin{frame}[fragile]{The blueprint (\textbf{THIS IS NOT CODE!})}
\begin{lstlisting}
Abstraction Player =
  Name, which is a sequence of characters
  PositionX, which is a number
  PositionY, which is a number
\end{lstlisting}

The abstraction above is called a \textbf{data structure}.

It is not valid Python code, but it is a blueprint specifying a recurrent set of attributes that often go together to identify a player.

\end{frame}

\SlideSection{Assignment}
\SlideSubSection{Assignment}
\begin{slide}{
\item Think of the project,
\item identify (at least) 3 data structures and
\item define the blueprints.
}\end{slide}



\SlideSubSection{Examples}
\begin{slide}{
\item We are now ready to implement our player data type
\item We will use a Python class to do so
\item We will then create concrete instances of it, and use them
}\end{slide}

\begin{frame}[fragile]{The blueprint to implement}
\begin{lstlisting}
Abstraction Player =
  Name, which is a string
  PositionX, which is a number
  PositionY, which is a number
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{The implemented class}
\begin{lstlisting}
class Player:
  def __init__(self, name, posX, posY):
    self.Name = name
    self.PositionX = posX
    self.PositionY = posY
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Creating concrete instances}
\begin{lstlisting}
playerOneName = "P1"
playerOnePositionX = 0.0
playerOnePositionY = 0.0

playerTwoName = "P2"
playerTwoPositionX = 5.0
playerTwoPositionY = 0.0

playerThreeName = "P3"
playerThreePositionX = 10.0
playerThreePositionY = 0.0
\end{lstlisting}

Becomes:

\begin{lstlisting}
playerOne   = Player("P1", 0.0, 0.0)
playerTwo   = Player("P2", 5.0, 0.0)
playerThree = Player("P3", 10.0, 0.0)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{The implemented class}
\begin{lstlisting}
class Player:
  def __init__(self, name, posX, posY):
    self.Name = name
    self.PositionX = posX
    self.PositionY = posY
\end{lstlisting}

General template:

\begin{lstlisting}
class <<Name>>:
  def __init__(self, <<v1>>, <<v2>>, ..., <<vN>):
    self.<<A1>> = <<v1>>
    self.<<A2>> = <<v2>>
    ...
    self.<<AN>> = <<vN>>
\end{lstlisting}

The class has thus: \texttt{name}, \texttt{initial values} $v_1$ through $v_N$, and \texttt{attributes} $A_1$ through $A_N$ initialized with \texttt{\_\_init\_\_}.
\texttt{self} is a reference to the \texttt{concrete instance} that is being set up.
\end{frame}


\begin{frame}[fragile]{Usage of Python classes}
Using a class:
\begin{lstlisting}
playerOne   = Player("P1", 0.0, 0.0)
\end{lstlisting}

General template:

\begin{lstlisting}
x = <<Name>>(<<v1>>, <<v2>>, ..., <<vN>)
\end{lstlisting}

Sets up a \texttt{concrete instance} of \texttt{<<Name>>} with some \texttt{initial values}.
\end{frame}


\begin{frame}[fragile]{Usage of Python classes}
Reading:
\begin{lstlisting}
print(x.<<A2>>)
\end{lstlisting}

Prints the value of the second \texttt{attribute} of the \texttt{concrete instance} called \texttt{x} of class \texttt{<<Name>>}.

//
Writing:
\begin{lstlisting}
x.<<A3>> = y
\end{lstlisting}

Assigns \texttt{y} as the new value of the third \texttt{attribute} of the \texttt{concrete instance} called \texttt{x} of class \texttt{<<Name>>}.
\end{frame}





\SlideSection{Assignment}
\SlideSubSection{Write your classes in Python}
\begin{slide}{
\item Write the data structures you defined before in Python classes
\item Test them out.
}\end{slide}







%%% Aliasing of references

\SlideSection{Designing data structures}
\SlideSubSection{Are we there yet?}
\begin{slide}{
\item We can keep extending our knowledge about the problem
\item For example, we might notice that \texttt{PositionX} and \texttt{PositionY} might happen in other places of the program
\item \textbf{What could we do?}
\pause
\item We could define a \texttt{Point2D} (or \texttt{Vector2D}) data structure!
}\end{slide}

\SlideSubSection{Refined data structures}
\begin{frame}[fragile]{Refined data structures}
\begin{lstlisting}
class position:
  def __init__(self, x, y):
    self.X = x
    self.Y = y
    
class PlayerRefined:
  def __init__(self, name, posX, posY):
    self.Name = name
    self.position = position(posX,posY)
\end{lstlisting}
\end{frame}

\begin{slide}{
\item Creation is precisely identical to the previous sample
\item The \texttt{\_\_init\_\_} of the \texttt{PlayerRefined} has the same inputs
\item Where we had \texttt{playerOne = Player("P1", 0.0, 0.0)}
\item Now we have \texttt{playerOne = PlayerRefined("P1", 0.0, 0.0)}
}\end{slide}

\begin{slide}{
\item Usage of the new player definition is almost identical to the previous
\item Only changes are lookups like: \texttt{playerOne.PositionY}
\item \textbf{What do they become now?}
\item \texttt{playerOne.Position.Y}
}\end{slide}


\SlideSection{Assignment}
\SlideSubSection{Build, in class, a series of data structures}
\begin{slide}{
\item Tyre
\item Wheel
\item Engine
\item Seat
\item Light
\item Person (driver and passenger)
\item Car
}\end{slide}





\SlideSubSection{What characterizes a good design of data structures?}
\begin{slide}{
\item \textbf{Reuse} of code in places where otherwise repetition would happen
\item \textbf{Encapsulation} of the semantics of the data structure
\item \textbf{Loose coupling} between the data structure and the rest of the program
}\end{slide}

\SlideSubSection{Reuse of code}
\begin{slide}{
\item Repetition is dangerous
\item A small change in one place but not in the others can lead to unexpected consequences
\item More code to read means more mental overhead
\item Actual work of the program is hidden under lots of noise and thus less visible
}\end{slide}

\SlideSubSection{Encapsulation}
\begin{slide}{
\item A data structure has a single, clear, well-defined goal
\item Its name clearly explains what it contains and does
\item There is no multiple functionality mix
\pause
\item It's a cold beer, not a cocktail
}\end{slide}

\SlideSubSection{Loose coupling}
\begin{slide}{
\item A data structure is a closed and complete unit
\item To use it, you just need to declare it and initialize it
\item The rest of the program integrates a well-designed data structure with minimal modification
}\end{slide}



\SlideSubSection{How do we verify all this?!?}
\begin{slide}{
\item Takes experience and good taste
\item It is an old story
\item Remember: you have the power to make your own life a living Hell...
\pause
\item ...unless you reason first and write code after
}\end{slide}




\SlideSection{Conclusion}
\SlideSubSection{Lecture topics}
\begin{slide}{
\item Abstraction is the fundamental mechanism that allows us to group concepts together and refer to them as if they were a single concept
\item For example, a name and two numbers became a \texttt{player}
\item We then use the new concept (the \texttt{player}) without having to explicitly mention all of its components every time
\item This makes it leaner for us to manipulate complex programs, as less concepts (``actors'') make an appearance
}\end{slide}

\begin{thankyou}
\end{thankyou}

\end{document}

\begin{slide}{
\item ...
}\end{slide}

\begin{frame}[fragile]
\begin{lstlisting}
...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\begin{codewithblock}{\item $x^y + \sum_i i^2$}
if x > y then 
  print x 
else 
  print y
\end{codewithblock}
\end{frame}


Score|Oud cijfer	Nieuw cijfer
0	0	0.0
12.5	1.3	0.9
25	2.5	1.8
37.5	3.8	2.8
50	5	3.7
62.5	6.3	4.6
75	7.5	5.5
87.5	8.8	7.8
100	10	10.0